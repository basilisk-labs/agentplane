/* eslint-disable @typescript-eslint/no-unused-vars */
import { execFile } from "node:child_process";
import { readFileSync } from "node:fs";
import {
  chmod,
  mkdir,
  mkdtemp,
  readdir,
  readFile,
  realpath,
  rm,
  writeFile,
} from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import { promisify } from "node:util";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";

import {
  defaultConfig,
  extractTaskSuffix,
  readTask,
  renderTaskReadme,
  type ResolvedProject,
} from "@agentplaneorg/core";

import { runCli } from "./run-cli.js";
import { BUNDLED_RECIPES_CATALOG } from "../recipes/bundled-recipes.js";
import { getVersion } from "../meta/version.js";
import {
  filterAgentsByWorkflow,
  loadAgentTemplates,
  loadAgentsTemplate,
} from "../agents/agents-template.js";
import * as taskBackend from "../backends/task-backend.js";
import {
  captureStdIO,
  cleanGitEnv,
  commitAll,
  configureGitUser,
  createUpgradeBundle,
  getAgentplaneHome,
  gitBranchExists,
  runCliSilent,
  mkGitRepoRoot,
  mkGitRepoRootWithBranch,
  mkTempDir,
  pathExists,
  registerAgentplaneHome,
  silenceStdIO,
  stageGitignoreIfPresent,
  writeConfig,
  writeDefaultConfig,
} from "./run-cli.test-helpers.js";
import { resolveUpdateCheckCachePath } from "./update-check.js";
import * as prompts from "./prompts.js";

registerAgentplaneHome();
let restoreStdIO: (() => void) | null = null;

beforeEach(() => {
  restoreStdIO = silenceStdIO();
});

afterEach(() => {
  restoreStdIO?.();
  restoreStdIO = null;
});

function stubTaskBackend(overrides: Partial<taskBackend.TaskBackend>): taskBackend.TaskBackend {
  return {
    id: "local",
    listTasks: vi.fn().mockResolvedValue([]),
    getTask: vi.fn().mockResolvedValue(null),
    writeTask: vi.fn().mockImplementation(() => Promise.resolve()),
    ...overrides,
  };
}

describe("runCli", () => {
  it("mode get prints workflow mode (default)", async () => {
    const root = await mkGitRepoRoot();
    const io = captureStdIO();
    try {
      const code = await runCli(["mode", "get", "--root", root]);
      expect(code).toBe(0);
      expect(io.stdout.trim()).toBe("direct");
    } finally {
      io.restore();
    }
  });

  it("mode set persists workflow_mode and prints the new mode", async () => {
    const root = await mkGitRepoRoot();

    const io = captureStdIO();
    try {
      const code = await runCli(["mode", "set", "branch_pr", "--root", root]);
      expect(code).toBe(0);
      expect(io.stdout.trim()).toBe("branch_pr");
    } finally {
      io.restore();
    }

    const configPath = path.join(root, ".agentplane", "config.json");
    const text = await readFile(configPath, "utf8");
    expect(text).toContain('"workflow_mode": "branch_pr"');

    const io2 = captureStdIO();
    try {
      const code2 = await runCli(["mode", "get", "--root", root]);
      expect(code2).toBe(0);
      expect(io2.stdout.trim()).toBe("branch_pr");
    } finally {
      io2.restore();
    }
  });

  it("mode set rejects invalid values", async () => {
    const root = await mkGitRepoRoot();
    const io = captureStdIO();
    try {
      const code = await runCli(["mode", "set", "nope", "--root", root]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Invalid value for mode");
      expect(io.stderr).toContain("Usage:");
      expect(io.stderr).toContain("agentplane mode set");
      expect(io.stderr).toContain("agentplane help mode set --compact");
    } finally {
      io.restore();
    }
  });

  it("ide sync writes Cursor and Windsurf rules from AGENTS.md", async () => {
    const root = await mkGitRepoRoot();
    await writeFile(path.join(root, "AGENTS.md"), "# Agents\n\nRules go here.\n", "utf8");

    const io = captureStdIO();
    try {
      const code = await runCli(["ide", "sync", "--root", root]);
      expect(code).toBe(0);
      expect(io.stdout).toContain(".cursor/rules/agentplane.mdc");
      expect(io.stdout).toContain(".windsurf/rules/agentplane.md");
    } finally {
      io.restore();
    }

    const cursorPath = path.join(root, ".cursor", "rules", "agentplane.mdc");
    const windsurfPath = path.join(root, ".windsurf", "rules", "agentplane.md");
    const cursorText = await readFile(cursorPath, "utf8");
    const windsurfText = await readFile(windsurfPath, "utf8");

    expect(cursorText).toContain("AUTOGENERATED by agentplane ide sync.");
    expect(cursorText).toContain("# Agents");
    expect(windsurfText).toBe(cursorText);
  });

  it("ide sync rejects unexpected args", async () => {
    const root = await mkGitRepoRoot();
    const io = captureStdIO();
    try {
      const code = await runCli(["ide", "sync", "extra", "--root", root]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Unexpected argument: extra");
      expect(io.stderr).toContain("Usage:");
      expect(io.stderr).toContain("agentplane ide sync");
      expect(io.stderr).toContain("agentplane help ide sync --compact");
    } finally {
      io.restore();
    }
  });

  it("init --yes creates baseline project files", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--root", root]);
      expect(code).toBe(0);
    } finally {
      io.restore();
    }

    const configPath = path.join(root, ".agentplane", "config.json");
    const backendPath = path.join(root, ".agentplane", "backends", "local", "backend.json");
    const redmineBackendPath = path.join(
      root,
      ".agentplane",
      "backends",
      "redmine",
      "backend.json",
    );
    const agentsPath = path.join(root, "AGENTS.md");
    expect(await pathExists(configPath)).toBe(true);
    expect(await pathExists(backendPath)).toBe(true);
    expect(await pathExists(redmineBackendPath)).toBe(true);
    expect(await pathExists(agentsPath)).toBe(true);

    const configText = await readFile(configPath, "utf8");
    expect(configText).toContain('"workflow_mode": "direct"');
    expect(configText).toContain('"config_path": ".agentplane/backends/local/backend.json"');

    const backendText = await readFile(backendPath, "utf8");
    const backend = JSON.parse(backendText) as Record<string, unknown>;
    expect(backend).toMatchObject({ id: "local", version: 1 });
    expect(backend).toHaveProperty("settings");
    expect(backend).not.toHaveProperty("module");
    expect(backend).not.toHaveProperty("class");
  });

  it("init --backend redmine sets backend config path", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--backend", "redmine", "--root", root]);
      expect(code).toBe(0);
    } finally {
      io.restore();
    }

    const configPath = path.join(root, ".agentplane", "config.json");
    const configText = await readFile(configPath, "utf8");
    expect(configText).toContain('"config_path": ".agentplane/backends/redmine/backend.json"');
  });

  it("init bootstraps git repo and commits install when git is missing", async () => {
    const root = await mkTempDir();
    const originalEnv = {
      GIT_AUTHOR_NAME: process.env.GIT_AUTHOR_NAME,
      GIT_AUTHOR_EMAIL: process.env.GIT_AUTHOR_EMAIL,
      GIT_COMMITTER_NAME: process.env.GIT_COMMITTER_NAME,
      GIT_COMMITTER_EMAIL: process.env.GIT_COMMITTER_EMAIL,
    };
    process.env.GIT_AUTHOR_NAME = "Test User";
    process.env.GIT_AUTHOR_EMAIL = "test@example.com";
    process.env.GIT_COMMITTER_NAME = "Test User";
    process.env.GIT_COMMITTER_EMAIL = "test@example.com";

    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--root", root]);
      expect(code).toBe(0);
    } finally {
      io.restore();
      process.env.GIT_AUTHOR_NAME = originalEnv.GIT_AUTHOR_NAME;
      process.env.GIT_AUTHOR_EMAIL = originalEnv.GIT_AUTHOR_EMAIL;
      process.env.GIT_COMMITTER_NAME = originalEnv.GIT_COMMITTER_NAME;
      process.env.GIT_COMMITTER_EMAIL = originalEnv.GIT_COMMITTER_EMAIL;
    }

    const gitDir = path.join(root, ".git");
    expect(await pathExists(gitDir)).toBe(true);

    const execFileAsync = promisify(execFile);
    const { stdout: subject } = await execFileAsync("git", ["log", "-1", "--pretty=%s"], {
      cwd: root,
      env: cleanGitEnv(),
    });
    expect(subject.trim()).toContain(`agentplane ${getVersion()}`);

    const { stdout: baseBranch } = await execFileAsync(
      "git",
      ["config", "--local", "--get", "agentplane.baseBranch"],
      { cwd: root, env: cleanGitEnv() },
    );
    expect(baseBranch.trim()).toBe("main");
  });

  it("init branch_pr defaults base branch to main in empty repo", async () => {
    const root = await mkTempDir();
    const originalEnv = {
      GIT_AUTHOR_NAME: process.env.GIT_AUTHOR_NAME,
      GIT_AUTHOR_EMAIL: process.env.GIT_AUTHOR_EMAIL,
      GIT_COMMITTER_NAME: process.env.GIT_COMMITTER_NAME,
      GIT_COMMITTER_EMAIL: process.env.GIT_COMMITTER_EMAIL,
    };
    process.env.GIT_AUTHOR_NAME = "Test User";
    process.env.GIT_AUTHOR_EMAIL = "test@example.com";
    process.env.GIT_COMMITTER_NAME = "Test User";
    process.env.GIT_COMMITTER_EMAIL = "test@example.com";

    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--workflow", "branch_pr", "--root", root]);
      expect(code).toBe(0);
    } finally {
      io.restore();
      process.env.GIT_AUTHOR_NAME = originalEnv.GIT_AUTHOR_NAME;
      process.env.GIT_AUTHOR_EMAIL = originalEnv.GIT_AUTHOR_EMAIL;
      process.env.GIT_COMMITTER_NAME = originalEnv.GIT_COMMITTER_NAME;
      process.env.GIT_COMMITTER_EMAIL = originalEnv.GIT_COMMITTER_EMAIL;
    }

    const configPath = path.join(root, ".agentplane", "config.json");
    await readFile(configPath, "utf8");

    const execFileAsync = promisify(execFile);
    const { stdout: baseBranch } = await execFileAsync(
      "git",
      ["config", "--local", "--get", "agentplane.baseBranch"],
      { cwd: root, env: cleanGitEnv() },
    );
    expect(baseBranch.trim()).toBe("main");
  });

  it("init in branch_pr skips hook enforcement for install commit", async () => {
    const root = await mkTempDir();
    const originalEnv = {
      GIT_AUTHOR_NAME: process.env.GIT_AUTHOR_NAME,
      GIT_AUTHOR_EMAIL: process.env.GIT_AUTHOR_EMAIL,
      GIT_COMMITTER_NAME: process.env.GIT_COMMITTER_NAME,
      GIT_COMMITTER_EMAIL: process.env.GIT_COMMITTER_EMAIL,
    };
    process.env.GIT_AUTHOR_NAME = "Test User";
    process.env.GIT_AUTHOR_EMAIL = "test@example.com";
    process.env.GIT_COMMITTER_NAME = "Test User";
    process.env.GIT_COMMITTER_EMAIL = "test@example.com";

    const cliPath = path.resolve(process.cwd(), "packages", "agentplane", "bin", "agentplane.js");
    const stubPath = path.join(root, "agentplane");
    const stubBody = ["#!/usr/bin/env sh", `exec node "${cliPath}" "$@"`, ""].join("\n");
    await writeFile(stubPath, stubBody, "utf8");
    await chmod(stubPath, 0o755);

    const originalPath = process.env.PATH;
    process.env.PATH = `${root}${path.delimiter}${originalPath ?? ""}`;

    const io = captureStdIO();
    try {
      const code = await runCli([
        "init",
        "--yes",
        "--workflow",
        "branch_pr",
        "--hooks",
        "yes",
        "--root",
        root,
      ]);
      expect(code).toBe(0);
    } finally {
      io.restore();
      process.env.PATH = originalPath;
      process.env.GIT_AUTHOR_NAME = originalEnv.GIT_AUTHOR_NAME;
      process.env.GIT_AUTHOR_EMAIL = originalEnv.GIT_AUTHOR_EMAIL;
      process.env.GIT_COMMITTER_NAME = originalEnv.GIT_COMMITTER_NAME;
      process.env.GIT_COMMITTER_EMAIL = originalEnv.GIT_COMMITTER_EMAIL;
    }

    const execFileAsync = promisify(execFile);
    const { stdout: subject } = await execFileAsync("git", ["log", "-1", "--pretty=%s"], {
      cwd: root,
      env: cleanGitEnv(),
    });
    expect(subject.trim()).toContain(`agentplane ${getVersion()}`);

    const { stdout: baseBranch } = await execFileAsync(
      "git",
      ["config", "--local", "--get", "agentplane.baseBranch"],
      { cwd: root, env: cleanGitEnv() },
    );
    expect(baseBranch.trim()).toBe("main");
  });

  it("init branch_pr keeps current branch as base in existing repo when non-interactive", async () => {
    const root = await mkGitRepoRootWithBranch("trunk");
    await configureGitUser(root);

    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--workflow", "branch_pr", "--root", root]);
      expect(code).toBe(0);
    } finally {
      io.restore();
    }

    const configPath = path.join(root, ".agentplane", "config.json");
    await readFile(configPath, "utf8");

    const execFileAsync = promisify(execFile);
    const { stdout: baseBranch } = await execFileAsync(
      "git",
      ["config", "--local", "--get", "agentplane.baseBranch"],
      { cwd: root, env: cleanGitEnv() },
    );
    expect(baseBranch.trim()).toBe("trunk");
  });

  it("init pins base branch to current branch in existing repo", async () => {
    const root = await mkGitRepoRootWithBranch("trunk");
    await configureGitUser(root);

    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--root", root]);
      expect(code).toBe(0);
    } finally {
      io.restore();
    }

    const configPath = path.join(root, ".agentplane", "config.json");
    await readFile(configPath, "utf8");

    const execFileAsync = promisify(execFile);
    const { stdout: baseBranch } = await execFileAsync(
      "git",
      ["config", "--local", "--get", "agentplane.baseBranch"],
      { cwd: root, env: cleanGitEnv() },
    );
    expect(baseBranch.trim()).toBe("trunk");
  });

  it("init writes AGENTS.md and agent templates for direct mode", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    const template = await loadAgentsTemplate();
    const expectedAgents = filterAgentsByWorkflow(template, "direct");
    const templates = await loadAgentTemplates();

    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--root", root]);
      expect(code).toBe(0);
    } finally {
      io.restore();
    }

    const agentsPath = path.join(root, "AGENTS.md");
    const agentsText = await readFile(agentsPath, "utf8");
    expect(agentsText).toBe(expectedAgents);

    const agentsDir = path.join(root, ".agentplane", "agents");
    const entries = await readdir(agentsDir);
    const jsonEntries = entries.filter((entry) => entry.endsWith(".json"));
    expect(jsonEntries.toSorted()).toEqual(templates.map((entry) => entry.fileName).toSorted());

    for (const agent of templates) {
      const target = path.join(agentsDir, agent.fileName);
      const contents = await readFile(target, "utf8");
      expect(contents).toBe(agent.contents);
    }
  });

  it("init filters AGENTS.md for branch_pr mode", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    const template = await loadAgentsTemplate();
    const expectedAgents = filterAgentsByWorkflow(template, "branch_pr");

    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--workflow", "branch_pr", "--root", root]);
      expect(code).toBe(0);
    } finally {
      io.restore();
    }

    const agentsPath = path.join(root, "AGENTS.md");
    const agentsText = await readFile(agentsPath, "utf8");
    expect(agentsText).toBe(expectedAgents);
  });

  it("init applies workflow, installs hooks, and runs ide sync", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    const stubPath = path.join(root, "agentplane");
    const stubBody = [
      "#!/usr/bin/env sh",
      'if [ "$1" = "hooks" ]; then',
      "  exit 0",
      "fi",
      "exit 0",
      "",
    ].join("\n");
    await writeFile(stubPath, stubBody, "utf8");
    await chmod(stubPath, 0o755);
    const originalPath = process.env.PATH;
    process.env.PATH = `${root}${path.delimiter}${originalPath ?? ""}`;
    const io = captureStdIO();
    try {
      const code = await runCli([
        "init",
        "--workflow",
        "branch_pr",
        "--ide",
        "cursor",
        "--hooks",
        "yes",
        "--require-plan-approval",
        "yes",
        "--require-network-approval",
        "no",
        "--require-verify-approval",
        "yes",
        "--root",
        root,
      ]);
      expect(code).toBe(0);
    } finally {
      process.env.PATH = originalPath;
      io.restore();
    }

    const configPath = path.join(root, ".agentplane", "config.json");
    const configText = await readFile(configPath, "utf8");
    expect(configText).toContain('"workflow_mode": "branch_pr"');
    expect(configText).toContain('"require_plan": true');
    expect(configText).toContain('"require_network": false');
    expect(configText).toContain('"require_verify": true');

    const cursorPath = path.join(root, ".cursor", "rules", "agentplane.mdc");
    const windsurfPath = path.join(root, ".windsurf", "rules", "agentplane.md");
    expect(await pathExists(cursorPath)).toBe(true);
    expect(await pathExists(windsurfPath)).toBe(false);

    const hooksDir = path.join(root, ".git", "hooks");
    const commitMsgPath = path.join(hooksDir, "commit-msg");
    const commitMsg = await readFile(commitMsgPath, "utf8");
    expect(commitMsg).toContain("agentplane-hook");
  });

  it("init rejects missing flags in non-tty mode", async () => {
    const root = await mkGitRepoRoot();
    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--root", root]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Non-interactive init requires");
      expect(io.stderr).toContain("Usage:");
      expect(io.stderr).toContain("agentplane init");
      expect(io.stderr).toContain("agentplane help init --compact");
    } finally {
      io.restore();
    }
  });

  it("init prompts for interactive defaults", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    const originalIsTTY = process.stdin.isTTY;
    Object.defineProperty(process.stdin, "isTTY", { value: true, configurable: true });
    const choice = vi.spyOn(prompts, "promptChoice").mockResolvedValue("branch_pr");
    const yesNo = vi.spyOn(prompts, "promptYesNo").mockResolvedValue(true);
    const promptInput = vi.spyOn(prompts, "promptInput").mockResolvedValue("");
    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--root", root]);
      expect(code).toBe(0);
      expect(choice).toHaveBeenCalled();
      expect(yesNo).toHaveBeenCalled();
      expect(promptInput).toHaveBeenCalled();
    } finally {
      Object.defineProperty(process.stdin, "isTTY", { value: originalIsTTY, configurable: true });
      choice.mockRestore();
      yesNo.mockRestore();
      promptInput.mockRestore();
      io.restore();
    }
  });

  it("init rejects unknown flags", async () => {
    const root = await mkGitRepoRoot();
    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--wat", "x", "--root", root]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Unknown option: --wat");
      expect(io.stderr).toContain("Usage:");
      expect(io.stderr).toContain("agentplane init");
    } finally {
      io.restore();
    }
  });

  it("init rejects unexpected arguments", async () => {
    const root = await mkGitRepoRoot();
    const io = captureStdIO();
    try {
      const code = await runCli(["init", "extra", "--root", root]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Unexpected argument: extra");
      expect(io.stderr).toContain("Usage:");
      expect(io.stderr).toContain("agentplane init");
    } finally {
      io.restore();
    }
  });

  it("init rejects invalid --ide values", async () => {
    const root = await mkGitRepoRoot();
    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--ide", "vscode", "--root", root]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Invalid value for --ide: vscode");
      expect(io.stderr).toContain("expected one of");
    } finally {
      io.restore();
    }
  });

  it("init rejects invalid --workflow values", async () => {
    const root = await mkGitRepoRoot();
    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--workflow", "fast", "--root", root]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Invalid value for --workflow: fast");
      expect(io.stderr).toContain("expected one of");
    } finally {
      io.restore();
    }
  });

  it("init rejects invalid --hooks values", async () => {
    const root = await mkGitRepoRoot();
    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--hooks", "maybe", "--root", root]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Invalid value for --hooks");
    } finally {
      io.restore();
    }
  });

  it("init refuses to overwrite existing config", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    await runCliSilent(["init", "--yes", "--root", root]);
    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--root", root]);
      expect(code).toBe(4);
      expect(io.stderr).toContain("Init conflicts detected");
      expect(io.stderr).toContain(".agentplane/config.json");
    } finally {
      io.restore();
    }
  });

  it("init validates recipes against bundled catalog", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    const original = [...BUNDLED_RECIPES_CATALOG.recipes];
    BUNDLED_RECIPES_CATALOG.recipes.length = 0;
    BUNDLED_RECIPES_CATALOG.recipes.push({
      id: "viewer",
      summary: "Viewer recipe",
      versions: [{ version: "1.0.0" }],
    });

    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--recipes", "viewer", "--root", root]);
      expect(code).toBe(0);
    } finally {
      BUNDLED_RECIPES_CATALOG.recipes.length = 0;
      BUNDLED_RECIPES_CATALOG.recipes.push(...original);
      io.restore();
    }
  });

  it("init lists conflicts for existing files by default", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    const agentplaneDir = path.join(root, ".agentplane");
    const configPath = path.join(agentplaneDir, "config.json");
    const backendPath = path.join(agentplaneDir, "backends", "local", "backend.json");
    await mkdir(path.join(agentplaneDir, "backends", "local"), { recursive: true });
    await writeFile(configPath, "legacy-config", "utf8");
    await writeFile(backendPath, "legacy-backend", "utf8");

    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--root", root]);
      expect(code).toBe(4);
      expect(io.stderr).toContain("Init conflicts detected");
      expect(io.stderr).toContain(".agentplane/config.json");
      expect(io.stderr).toContain(".agentplane/backends/local/backend.json");
      expect(io.stderr).toContain("--force");
      expect(io.stderr).toContain("--backup");
    } finally {
      io.restore();
    }
  });

  it("init --force overwrites conflicting files", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    const agentplaneDir = path.join(root, ".agentplane");
    const configPath = path.join(agentplaneDir, "config.json");
    const backendPath = path.join(agentplaneDir, "backends", "local", "backend.json");
    await mkdir(path.join(agentplaneDir, "backends", "local"), { recursive: true });
    await writeFile(configPath, "legacy-config", "utf8");
    await writeFile(backendPath, "legacy-backend", "utf8");

    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--force", "--root", root]);
      expect(code).toBe(0);
    } finally {
      io.restore();
    }

    const configText = await readFile(configPath, "utf8");
    expect(configText).toContain('"workflow_mode": "direct"');
  });

  it("init --backup preserves conflicting files with timestamped backups", async () => {
    const root = await mkGitRepoRoot();
    await configureGitUser(root);
    const agentplaneDir = path.join(root, ".agentplane");
    const configPath = path.join(agentplaneDir, "config.json");
    const backendPath = path.join(agentplaneDir, "backends", "local", "backend.json");
    await mkdir(path.join(agentplaneDir, "backends", "local"), { recursive: true });
    await writeFile(configPath, "legacy-config", "utf8");
    await writeFile(backendPath, "legacy-backend", "utf8");

    const io = captureStdIO();
    try {
      const code = await runCli(["init", "--yes", "--backup", "--root", root]);
      expect(code).toBe(0);
    } finally {
      io.restore();
    }

    const agentplaneEntries = await readdir(agentplaneDir);
    expect(agentplaneEntries.some((entry) => entry.startsWith("config.json.bak-"))).toBe(true);

    const backendEntries = await readdir(path.join(agentplaneDir, "backends", "local"));
    expect(backendEntries.some((entry) => entry.startsWith("backend.json.bak-"))).toBe(true);

    const configText = await readFile(configPath, "utf8");
    expect(configText).toContain('"workflow_mode": "direct"');
  });

  it("upgrade applies bundle changes and writes backups by default", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    await writeFile(path.join(root, "AGENTS.md"), "legacy agents", "utf8");
    await mkdir(path.join(root, ".agentplane", "agents"), { recursive: true });
    await writeFile(
      path.join(root, ".agentplane", "agents", "ORCHESTRATOR.json"),
      '{"legacy":true}\n',
      "utf8",
    );

    const { bundlePath, checksumPath } = await createUpgradeBundle({
      "AGENTS.md": "# AGENTS\n\nUpdated\n",
      ".agentplane/agents/ORCHESTRATOR.json": '{"updated":true}\n',
    });

    const io = captureStdIO();
    try {
      const code = await runCli([
        "upgrade",
        "--auto",
        "--bundle",
        bundlePath,
        "--checksum",
        checksumPath,
        "--root",
        root,
      ]);
      expect(code).toBe(0);
      expect(io.stdout).toContain("Upgrade applied");
    } finally {
      io.restore();
    }

    const agentsText = await readFile(path.join(root, "AGENTS.md"), "utf8");
    expect(agentsText).toContain("Updated");

    const agentEntries = await readdir(path.join(root, ".agentplane", "agents"));
    expect(agentEntries.some((entry) => entry.startsWith("ORCHESTRATOR.json.bak-"))).toBe(true);
    const rootEntries = await readdir(root);
    expect(rootEntries.some((entry) => entry.startsWith("AGENTS.md.bak-"))).toBe(true);
  });

  it("upgrade --dry-run reports changes without modifying files", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    await writeFile(path.join(root, "AGENTS.md"), "legacy agents", "utf8");

    const { bundlePath, checksumPath } = await createUpgradeBundle({
      "AGENTS.md": "# AGENTS\n\nUpdated\n",
    });

    const io = captureStdIO();
    try {
      const code = await runCli([
        "upgrade",
        "--dry-run",
        "--bundle",
        bundlePath,
        "--checksum",
        checksumPath,
        "--root",
        root,
      ]);
      expect(code).toBe(0);
      expect(io.stdout).toContain("Upgrade dry-run");
    } finally {
      io.restore();
    }

    const agentsText = await readFile(path.join(root, "AGENTS.md"), "utf8");
    expect(agentsText).toContain("legacy agents");
    const rootEntries = await readdir(root);
    expect(rootEntries.some((entry) => entry.startsWith("AGENTS.md.bak-"))).toBe(false);
  });

  it("upgrade requires --yes in non-tty mode when require_network=true and it would fetch remote assets", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const io = captureStdIO();
    try {
      const code = await runCli(["upgrade", "--remote", "--dry-run", "--root", root]);
      expect(code).toBe(3);
      expect(io.stderr).toContain("--yes");
    } finally {
      io.restore();
    }
  });

  it("upgrade validates bundle/checksum flag combinations", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const { bundlePath, checksumPath } = await createUpgradeBundle({
      "AGENTS.md": "# AGENTS\n\nUpdated\n",
    });

    const cases = [
      {
        args: ["upgrade", "--bundle", bundlePath, "--root", root],
        msg: "Options --bundle and --checksum must be provided together",
      },
      {
        args: ["upgrade", "--checksum", checksumPath, "--root", root],
        msg: "Options --bundle and --checksum must be provided together",
      },
    ];

    for (const entry of cases) {
      const io = captureStdIO();
      try {
        const code = await runCli(entry.args);
        expect(code).toBe(2);
        expect(io.stderr).toContain(entry.msg);
        expect(io.stderr).toContain("Usage:");
        expect(io.stderr).toContain("agentplane upgrade");
        expect(io.stderr).toContain("agentplane help upgrade --compact");
      } finally {
        io.restore();
      }
    }
  });

  it("upgrade parses extended flags with a bundle", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    await writeFile(path.join(root, "AGENTS.md"), "legacy agents", "utf8");

    const { bundlePath, checksumPath } = await createUpgradeBundle({
      "AGENTS.md": "# AGENTS\n\nUpdated\n",
    });

    const io = captureStdIO();
    try {
      const code = await runCli([
        "upgrade",
        "--dry-run",
        "--no-backup",
        "--tag",
        "v1.0.0",
        "--asset",
        "agentplane-upgrade.tar.gz",
        "--checksum-asset",
        "agentplane-upgrade.tar.gz.sha256",
        "--bundle",
        bundlePath,
        "--checksum",
        checksumPath,
        "--root",
        root,
      ]);
      expect(code).toBe(0);
      expect(io.stdout).toContain("Upgrade dry-run");
    } finally {
      io.restore();
    }
  });

  it("upgrade rejects non-github framework sources", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const configPath = path.join(root, ".agentplane", "config.json");
    const config = JSON.parse(await readFile(configPath, "utf8")) as Record<string, unknown>;
    (config.framework as Record<string, unknown>).source = "https://example.com/agentplane";
    await writeFile(configPath, JSON.stringify(config, null, 2), "utf8");

    const io = captureStdIO();
    try {
      const code = await runCli(["upgrade", "--remote", "--dry-run", "--root", root]);
      expect(code).toBe(1);
      expect(io.stderr).toContain("Invalid field config.framework.source: expected GitHub URL");
    } finally {
      io.restore();
    }
  });

  it("backend rejects unknown subcommands", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const io = captureStdIO();
    try {
      const code = await runCli(["backend", "nope", "--root", root]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Usage:");
      expect(io.stderr).toContain("agentplane backend sync");
    } finally {
      io.restore();
    }
  });

  it("backend sync routes to configured backend", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const io = captureStdIO();
    try {
      const code = await runCli([
        "backend",
        "sync",
        "local",
        "--direction",
        "pull",
        "--root",
        root,
      ]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Backend does not support sync()");
    } finally {
      io.restore();
    }
  });

  it("backend sync rejects invalid flags", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const cases: { args: string[] }[] = [
      {
        args: ["backend", "sync", "--direction", "sideways"],
      },
      { args: ["backend", "sync", "--conflict", "nope"] },
      { args: ["backend", "sync", "one", "two"] },
      { args: ["backend", "sync", "--wat"] },
    ];

    for (const entry of cases) {
      const io = captureStdIO();
      try {
        const code = await runCli([...entry.args, "--root", root]);
        expect(code).toBe(2);
        expect(io.stderr).toContain("Usage:");
        expect(io.stderr).toContain("agentplane backend sync");
      } finally {
        io.restore();
      }
    }
  });

  it("backend sync forwards flags to the backend", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const sync = vi.fn().mockImplementation(() => Promise.resolve());
    const resolved: ResolvedProject = {
      gitRoot: root,
      agentplaneDir: path.join(root, ".agentplane"),
    };
    const loadResult = {
      backend: stubTaskBackend({ id: "redmine", sync }),
      backendId: "redmine",
      resolved,
      config: defaultConfig(),
      backendConfigPath: path.join(root, ".agentplane", "backends", "redmine", "backend.json"),
    } satisfies Awaited<ReturnType<typeof taskBackend.loadTaskBackend>>;
    const spy = vi.spyOn(taskBackend, "loadTaskBackend").mockResolvedValue(loadResult);

    const io = captureStdIO();
    try {
      const code = await runCli([
        "backend",
        "sync",
        "redmine",
        "--direction",
        "push",
        "--conflict",
        "prefer-local",
        "--yes",
        "--root",
        root,
      ]);
      expect(code).toBe(0);
      expect(sync).toHaveBeenCalledWith({
        direction: "push",
        conflict: "prefer-local",
        quiet: false,
        confirm: true,
      });
    } finally {
      io.restore();
      spy.mockRestore();
    }
  });

  it("backend sync requires --yes in non-tty mode when require_network=true and backend is non-local", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const sync = vi.fn().mockImplementation(() => Promise.resolve());
    const resolved: ResolvedProject = {
      gitRoot: root,
      agentplaneDir: path.join(root, ".agentplane"),
    };
    const loadResult = {
      backend: stubTaskBackend({ id: "redmine", sync }),
      backendId: "redmine",
      resolved,
      config: defaultConfig(),
      backendConfigPath: path.join(root, ".agentplane", "backends", "redmine", "backend.json"),
    } satisfies Awaited<ReturnType<typeof taskBackend.loadTaskBackend>>;
    const spy = vi.spyOn(taskBackend, "loadTaskBackend").mockResolvedValue(loadResult);

    const io = captureStdIO();
    try {
      const code = await runCli([
        "backend",
        "sync",
        "redmine",
        "--direction",
        "push",
        "--root",
        root,
      ]);
      expect(code).toBe(3);
      expect(io.stderr).toContain("--yes");
      expect(sync).not.toHaveBeenCalled();
    } finally {
      io.restore();
      spy.mockRestore();
    }
  });

  it("sync routes to configured backend", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const io = captureStdIO();
    try {
      const code = await runCli(["sync", "--direction", "pull", "--root", root]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Backend does not support sync()");
    } finally {
      io.restore();
    }
  });

  it("sync rejects invalid flags", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const cases: { args: string[]; msg: string }[] = [
      { args: ["sync", "--direction", "sideways"], msg: "Usage:" },
      { args: ["sync", "--conflict", "nope"], msg: "Usage:" },
      { args: ["sync", "one", "two"], msg: "Usage:" },
      { args: ["sync", "--wat"], msg: "Usage:" },
    ];

    for (const entry of cases) {
      const io = captureStdIO();
      try {
        const code = await runCli([...entry.args, "--root", root]);
        expect(code).toBe(2);
        expect(io.stderr).toContain(entry.msg);
        expect(io.stderr).toContain("agentplane sync");
        expect(io.stderr).toContain("agentplane help sync --compact");
      } finally {
        io.restore();
      }
    }
  });

  it("sync forwards flags to the backend", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const sync = vi.fn().mockImplementation(() => Promise.resolve());
    const resolved: ResolvedProject = {
      gitRoot: root,
      agentplaneDir: path.join(root, ".agentplane"),
    };
    const loadResult = {
      backend: stubTaskBackend({ id: "redmine", sync }),
      backendId: "redmine",
      resolved,
      config: defaultConfig(),
      backendConfigPath: path.join(root, ".agentplane", "backends", "redmine", "backend.json"),
    } satisfies Awaited<ReturnType<typeof taskBackend.loadTaskBackend>>;
    const spy = vi.spyOn(taskBackend, "loadTaskBackend").mockResolvedValue(loadResult);

    const io = captureStdIO();
    try {
      const code = await runCli([
        "sync",
        "redmine",
        "--direction",
        "push",
        "--conflict",
        "prefer-local",
        "--yes",
        "--root",
        root,
      ]);
      expect(code).toBe(0);
      expect(sync).toHaveBeenCalledWith({
        direction: "push",
        conflict: "prefer-local",
        quiet: false,
        confirm: true,
      });
    } finally {
      io.restore();
      spy.mockRestore();
    }
  });

  it("sync requires --yes in non-tty mode when require_network=true and backend is non-local", async () => {
    const root = await mkGitRepoRoot();
    await writeDefaultConfig(root);
    const sync = vi.fn().mockImplementation(() => Promise.resolve());
    const resolved: ResolvedProject = {
      gitRoot: root,
      agentplaneDir: path.join(root, ".agentplane"),
    };
    const loadResult = {
      backend: stubTaskBackend({ id: "redmine", sync }),
      backendId: "redmine",
      resolved,
      config: defaultConfig(),
      backendConfigPath: path.join(root, ".agentplane", "backends", "redmine", "backend.json"),
    } satisfies Awaited<ReturnType<typeof taskBackend.loadTaskBackend>>;
    const spy = vi.spyOn(taskBackend, "loadTaskBackend").mockResolvedValue(loadResult);

    const io = captureStdIO();
    try {
      const code = await runCli(["sync", "redmine", "--direction", "push", "--root", root]);
      expect(code).toBe(3);
      expect(io.stderr).toContain("--yes");
      expect(sync).not.toHaveBeenCalled();
    } finally {
      io.restore();
      spy.mockRestore();
    }
  });

  it("upgrade rejects unexpected positional args", async () => {
    const io = captureStdIO();
    try {
      const code = await runCli(["upgrade", "extra"]);
      expect(code).toBe(2);
      expect(io.stderr).toContain("Unexpected argument: extra");
      expect(io.stderr).toContain("Usage:");
      expect(io.stderr).toContain("agentplane upgrade");
    } finally {
      io.restore();
    }
  });
});
