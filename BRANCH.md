# 1) Где реально рождаются конфликты в текущем AgentPlane

## 1.1. Главный источник конфликтов: монолитные/производные файлы

- **`.agentplane/tasks.json`** — по смыслу “export”, но если его коммитить, он будет конфликтовать почти всегда (две ветки добавили/изменили задачи → один JSON).
- Любые “сводные” файлы/индексы в репозитории имеют тот же риск.

## 1.2. Нормальный источник конфликтов: один task правят в двух ветках

- `.agentplane/tasks/<task-id>/README.md` — конфликт ожидаем и является “легитимным”, если два человека реально правили один task параллельно.

## 1.3. Текущий `base_branch` в конфиге — концептуально и практически неверное место

Фидбек твоего товарища в этой части рационален: “base branch” — **локальная Git‑реальность**, а не общекомандная настройка, которую надо коммитить в `.agentplane/config.json`.

Критичный факт: в твоём коде `getBaseBranch()` вообще не читает `config.base_branch`, а использует **git config** `agentplane.baseBranch` с fallback на `"main"`. То есть поле `base_branch` в конфиге сейчас:

- создаёт иллюзию важности,
- может провоцировать коммит‑конфликты в конфиге,
- при этом фактически не управляет поведением.

# 2) Цели branching‑модели для минимизации конфликтов

1. **Убрать из репозитория всё производное/сводное**, что часто меняется (в первую очередь `tasks.json`).
2. Сделать так, чтобы “параллельная работа” почти всегда означала “новые файлы/директории”, а не “правки одного файла”.
3. Привязать “base branch” к **локальной** настройке (git config), а не к коммитящемуся конфигу.
4. Сохранить гибкость:
   - простой режим для обычной разработки (direct),
   - строгий режим для “интегратора”/симуляции PR (branch_pr),
   - возможность работать “от feature‑branch” без специальных костылей.

# 3) Рекомендованная целевая модель: “Effective Base Branch”

Вместо “base_branch в config” вводим **понятие эффективной базовой ветки** (effective base), которое определяется локально и предсказуемо.

## 3.1. Алгоритм выбора base (предлагаю такой приоритет)

1. `--base <name>` (явное указание в команде)
2. `git config --local agentplane.baseBranch` (пин)
3. fallback:
   - **для branch_pr**: текущая ветка (самый гибкий вариант для работы “от feature‑branch”)
   - **для direct**: base вообще не нужен для большинства команд, можно не резолвить

Почему для branch_pr fallback = current:

- снижает трение (можно включить branch_pr на feature‑ветке и жить локально),
- минимизирует конфликты в команде (каждый dev может иметь свой base = свой feature branch),
- интегратор, которому нужен base = main, просто делает `agentplane branch base set main`.

## 3.2. Команды управления base (UX)

Сейчас у тебя есть `branch base get|set`. Я бы расширил:

- `agentplane branch base set <branch>` — как сейчас (пин в git config)
- `agentplane branch base set --current` — пин на текущую ветку
- `agentplane branch base clear` — удалить `agentplane.baseBranch`
- `agentplane branch base explain` — вывести:
  - текущая ветка
  - pinned base (если есть)
  - effective base (по правилам)
  - предупреждения (если base не существует локально и т.п.)

Это сильно снижает “магичность” и помогает командам.

# 4) Два рекомендуемых сценария работы (оба минимизируют конфликты)

## Сценарий A — “Обычный Git‑пайплайн” (лучший по простоте)

Подходит большинству команд (и к фидбеку товарища ближе всего).

1. Человек создаёт feature branch вручную (или AgentPlane помогает, опционально).
2. Ветка = единица работы одного разработчика.
3. AgentPlane работает в **direct mode**:
   - задачи создаются/обновляются в текущей ветке,
   - коммиты содержат и код, и task‑доки.

4. PR/MR в родительскую ветку.

**Почему конфликтов мало**

- добавляются новые директории `.agentplane/tasks/<id>/...` (git это мерджит почти всегда без конфликтов),
- **нет `tasks.json` в репозитории** (ключевой пункт).

## Сценарий B — “Строгий branch_pr внутри feature branch” (максимальные гардрейлы)

Если вам реально нужен разделённый пайплайн “задача → PR artifacts → integrate”, но без общей “main как база для всех”.

1. Dev создаёт feature branch.
2. Делает `agentplane branch base set --current` (base = feature branch).
3. `workflow_mode = branch_pr`:
   - `work start` создаёт task‑ветку/ворктри,
   - код живёт в task‑ветках,
   - интеграция (`integrate`) льёт в feature base,

4. PR feature→main делается вручную.

**Почему конфликтов мало**

- base у каждого dev свой, “single-writer”.
- общая main не используется как координационная точка AgentPlane (если вы этого не хотите).

# 5) Конкретные изменения во фреймворке (таски для разработки)

Ниже — то, что нужно реализовать, чтобы ветки работали “как у взрослых” и с минимумом конфликтов.

---

## AP-BR-01 — Убрать `base_branch` из `.agentplane/config.json` как коммитящуюся настройку

**Проблема**
`base_branch` не должен быть в командном конфиге; плюс сейчас он фактически не влияет на `getBaseBranch()`.

**Решение**

- Удалить поле из:
  - `packages/spec/schemas/config.schema.json`
  - `packages/spec/examples/config.json`
  - `packages/core/src/config.ts` (type + default + validate)

- Сохранить миграционную совместимость:
  - если поле есть в существующем config — игнорировать, и (опционально) вывести warning.

**Приёмка**

- Никакие команды больше не требуют `config.base_branch`.
- `agentplane branch base get/set` остаётся источником base через git config.

---

## AP-BR-02 — Ввести единый резолвер effective base branch

**Проблема**
Разные команды могут использовать base по-разному, плюс нужен предсказуемый fallback.

**Решение**

- `resolveBaseBranch({ cwd, rootOverride, cliBaseOpt, mode })`:
  - если `--base` → он
  - иначе pinned git config
  - иначе:
    - если mode=branch_pr → current branch
    - иначе → `null`/не требуется

**Приёмка**

- `work start / integrate / cleanup merged / hook guard` используют **одно место** резолвинга.
- Появляется `branch base explain` (см. AP-BR-03).

---

## AP-BR-03 — Расширить branch‑команды для удобства командной работы

**Решение**

- `branch base set --current`
- `branch base clear`
- `branch base explain`

**Приёмка**

- Пользователь без чтения кода понимает, какая ветка является base и почему.

---

## AP-BR-04 — Исправить/согласовать документацию про direct mode и `work start`

**Проблема**
Документация говорит, что в direct mode `work start` “опционален”, но код сейчас требует `branch_pr`.

**Вариант 1 (рекомендую)**: поддержать `work start` в direct mode

- В direct mode команда может:
  - создать branch `task/<task-id>/<slug>` от **текущего HEAD**
  - (опционально) создать worktree
  - не требовать base branch
  - не включать строгие PR artifacts (или создавать минимальный scaffold)

**Вариант 2**: обновить доки и сказать “work start только branch_pr”.

**Почему вариант 1 полезен для минимизации конфликтов**

- стандартизирует “одна задача → одна ветка”, что естественно уменьшает параллельные правки одного task‑README.

---

# 6) Самый важный практический шаг против конфликтов: перестать коммитить `tasks.json`

## AP-BR-05 — `tasks.json` должен стать локальным артефактом (export only)

**Проблема**
Монолитный snapshot почти гарантирует конфликты между ветками.

**Решение (рекомендованная политика)**

1. По умолчанию добавить в `.gitignore`:
   - `.agentplane/tasks.json`
   - `.agentplane/cache/`
   - `.agentplane/worktrees/`

2. `tasks.json` генерировать только по команде `agentplane export` (или аналог), либо по явному флагу.
3. В hooks:
   - если файл не трекается — он не конфликтует; защита коммитов станет почти не нужна.
   - если кто-то всё же хочет его коммитить — пусть делает осознанно (`AGENT_PLANE_ALLOW_TASKS=1`).

**Дополнительно (опционально, но сильно помогает)**

- Перенести default `paths.tasks_path` на `.agentplane/exports/tasks.json` (или в глобальный кеш), чтобы визуально отрезать от “рабочих” файлов.

**Приёмка**

- В типичном PR две ветки не конфликтуют из‑за `tasks.json`, потому что его нет в diff.

---

# 7) Дополнительные техники снижения конфликтов (опциональные, но сильные)

## 7.1. Стабилизировать форматирование task README

Чем менее “шумный” diff, тем меньше конфликтов:

- стабильный порядок ключей frontmatter,
- стабильные переводы строк,
- нормализация секций.

(У тебя это уже частично есть, но важно сделать единым модулем в core, чтобы разные команды не форматировали по-разному.)

## 7.2. (Продвинуто) Перевести комментарии/статусы в append-only events

Если когда-нибудь потребуется параллельное редактирование одного task разными людьми без конфликтов, лучшая схема:

- `.agentplane/tasks/<id>/events/<timestamp>_<author>.json` (или `.md`)
- README становится “рендером” из событий (или содержит только базовую шапку)

Это почти убивает merge-conflicts на “логах статусов”, но сложнее в реализации и требует ясной политики рендера.

# 8) Резюме: что я бы сделал “по минимуму”, но с максимальным эффектом

1. **Убрать `base_branch` из коммитящегося конфига**, оставить base только в git config (`agentplane.baseBranch`) + `--base`.
2. **Сделать fallback base=current branch для branch_pr**, чтобы можно было работать “от feature‑ветки” без настройки.
3. **Перестать коммитить `tasks.json`** (gitignore по умолчанию + export по команде).
4. (Опционально, но очень желательно) **разрешить `work start` в direct mode** как “создать task‑ветку от текущей”, чтобы команды работали по стандартному паттерну “1 задача → 1 ветка”.
