---
title: "Architecture"
description: "How the CLI, backends, tasks, and recipes fit together."
---

## What runs where

Agent Plane has three layers with different responsibilities:

1. CLI runtime (`packages/agentplane/src`)
2. Shared models and config (`packages/core/src`)
3. JSON schema/spec layer (`packages/spec/schemas`)

The runtime layer owns command behavior. The core layer owns parsing and shared contracts. The spec layer is the canonical schema source, synchronized into `packages/core/schemas`.

## CLI runtime map

- Command entry and global argument handling:
  - `packages/agentplane/src/cli/run-cli.ts`
- Command registry and lazy loading:
  - `packages/agentplane/src/cli/run-cli/command-catalog.ts`
- Command handlers:
  - `packages/agentplane/src/commands/**`
- Task backend integration:
  - `packages/agentplane/src/backends/task-backend/load.ts`
- Redmine backend implementation:
  - `packages/agentplane/src/backends/task-backend/redmine-backend.ts`

## Core map

- Project resolution:
  - `packages/core/src/project.ts`
- Config parsing and defaults:
  - `packages/core/src/config.ts`
- Task document and snapshot primitives:
  - `packages/core/src/task-*`

## Runtime data flow

1. CLI resolves project root and reads `.agentplane/config.json`.
2. Command parser resolves command spec and validates flags.
3. Handler loads backend via `tasks_backend.config_path`.
4. Command mutates task state in backend storage.
5. Optional exports write `.agentplane/tasks.json`.
6. Task docs live in `.agentplane/tasks/<task-id>/README.md`.

## Upgrade and policy flow

`agentplane upgrade` applies managed framework assets and can emit upgrade review artifacts. In agent mode it writes run artifacts under `.agentplane/.upgrade/agent/<runId>/`, including `review.json` for semantic merge decisions.

Policy enforcement happens in command handlers and guard flows:

- commit subject and suffix validation
- allowlist path checks
- approval checks (network, force and other gated actions)
- lifecycle gates (dependencies, verification constraints, plan rules)

## Release flow

Release is split into planning and apply:

1. `agentplane release plan` generates patch candidate and notes inputs.
2. `agentplane release apply` updates versions and changelog artifacts.
3. Local prepublish gates must pass before `--push`.
4. npm publish is GitHub-only with provenance enforced by package scripts and workflow checks.

## Related docs

- [Project layout](project-layout)
- [CLI contract](cli-contract)
- [Release and publishing](release-and-publishing)
- [Tasks and backends](../user/tasks-and-backends)
