---
title: "How recipes work"
description: "Install, inspect, and execute recipes in the current CLI runtime."
---

This page describes runtime behavior behind `recipes` and `scenario` commands.

## Install flow

1. Resolve source (`--name`, `--path`, or `--url`).
2. Download when source is remote.
3. Extract archive and locate `manifest.json`.
4. Validate manifest and scenario definitions.
5. Copy recipe into global recipe store.
6. Update installed recipes metadata.
7. Optionally apply recipe-provided agents into `.agentplane/agents/`.

## Listing and inspection

- `recipes list` reads installed metadata and prints short entries.
- `recipes info` and `recipes explain` read manifest-backed details.
- `scenario list` enumerates known scenarios from installed recipes.
- `scenario info` prints scenario details for one `<recipe:scenario>`.

## Scenario run flow

`scenario run`:

1. Parses `<recipe:scenario>` id.
2. Loads recipe manifest and scenario definition.
3. Resolves referenced tools.
4. Executes steps sequentially.
5. Writes per-step logs and run report artifacts.

Typical run artifact path:

- `.agentplane/recipes/<recipe-id>/runs/<run-id>/`

Common files:

- `meta.json`
- `report.json`
- `step-<n>-<tool>/stdout.log`
- `step-<n>-<tool>/stderr.log`

## Environment behavior

Recipe tools inherit process environment.
When command runs inside a project, CLI loads `.env` (without overriding already exported vars).
Runtime also sets recipe-specific env keys such as run dir and cache dir for tool steps.

## Caching behavior

- Remote index cache is stored globally.
- `recipes list-remote --refresh` forces index refresh.
- `recipes cache prune` removes stale cached entries and supports `--dry-run`.

## Failure behavior

Common hard failures:

- missing or invalid manifest
- unsupported archive structure
- unknown scenario id
- missing tool referenced by a scenario step
- network/download errors for remote sources

On failure, CLI exits non-zero and reports an error with standard error code mapping.
